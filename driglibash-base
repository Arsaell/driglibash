###############################################################################
#                             Driglibash pack 1
#                 Usual helper functions for bash scripts
#               https://github.com/adrianamaglio/driglibash
###############################################################################

trap 'die "Received sigint"' INT

# Output on standard error output #
yell() {
  echo >&2 -e "$@"
}

# Print an error, clean and exit #
die() {
  yell "$@"
  clean
  exit 1
}

# Exit on error if not root #
root_or_die() {
  if [ "$UID" -ne 0 ] ; then
    die "You need to be root"
  fi
}

# Execute a command and die if it returns with error #
run() {
  while true ; do
    "$@"
    code=$?
    if [ "$code" -ne 0 ] ; then
      yell "command [$*] failed with error code $code"
      if "$driglibash_run_retry" ; then
        echo "RetryÂ [Y/n] ?"
        read answer
        if [ "$answer" == "y" ] || [ "$answer" == "Y" ] || [ -z "$answer" ] ; then
          continue
        fi
      fi
    fi
    die "Aborting"
  done
}

# Clean exit #
# Record command lines passed as argument and execute them all when called without args #
# One argument = One command #
# TODO append or prepend according to arg
clean() {
  if [ "$#" -eq 0 ] ; then
    echo "Cleaning"
    for action in "${driglibash_clean_actions[@]}" ; do
      echo "> $action"
      $action
    done
  elif [ "$#" -eq 1 ] ; then
    driglibash_clean_actions+=("$1")
  elif [ "$#" -eq 2 ] ; then
    case "$1" in
      "pre")
        driglibash_clean_actions+=("$1")
        ;;
      "post")
        driglibash_clean_actions+=("$1")
        ;;
      "del")
        for i in "${!driglibash_clean_actions[@]}" ; do
          if [ "$1" == "$i" ] ; then
            unset driglibash_clean_actions[$i] 
            break
          fi
        done
        ;;
      *)
        die "action '$1' not supported"
    esac
  else
    die "Bad clean usage, receveid more than three arg"
  fi
}

# tells where your executable is (absolute path). Follow simlinks if any argument provided
where() {
  if [ -z "$1" ] ; then
    echo "$( cd -P "$( dirname "$1" )" && pwd )"
  else
    SOURCE="$0"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
      DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
      SOURCE="$(readlink "$SOURCE")"
      [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    
    echo $DIR
  fi  
}

